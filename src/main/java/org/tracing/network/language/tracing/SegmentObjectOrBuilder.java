// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Tracing.proto

package org.tracing.network.language.tracing;

public interface SegmentObjectOrBuilder extends
    // @@protoc_insertion_point(interface_extends:deeptracing.v1.SegmentObject)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * A string id represents the whole trace.
   * </pre>
   *
   * <code>string traceId = 1;</code>
   * @return The traceId.
   */
  java.lang.String getTraceId();
  /**
   * <pre>
   * A string id represents the whole trace.
   * </pre>
   *
   * <code>string traceId = 1;</code>
   * @return The bytes for traceId.
   */
  com.google.protobuf.ByteString
      getTraceIdBytes();

  /**
   * <pre>
   * A unique id represents this segment. Other segments could use this id to reference as a child segment.
   * </pre>
   *
   * <code>string traceSegmentId = 2;</code>
   * @return The traceSegmentId.
   */
  java.lang.String getTraceSegmentId();
  /**
   * <pre>
   * A unique id represents this segment. Other segments could use this id to reference as a child segment.
   * </pre>
   *
   * <code>string traceSegmentId = 2;</code>
   * @return The bytes for traceSegmentId.
   */
  com.google.protobuf.ByteString
      getTraceSegmentIdBytes();

  /**
   * <pre>
   * Span collections included in this segment.
   * </pre>
   *
   * <code>repeated .deeptracing.v1.SpanObject spans = 3;</code>
   */
  java.util.List<org.tracing.network.language.tracing.SpanObject> 
      getSpansList();
  /**
   * <pre>
   * Span collections included in this segment.
   * </pre>
   *
   * <code>repeated .deeptracing.v1.SpanObject spans = 3;</code>
   */
  org.tracing.network.language.tracing.SpanObject getSpans(int index);
  /**
   * <pre>
   * Span collections included in this segment.
   * </pre>
   *
   * <code>repeated .deeptracing.v1.SpanObject spans = 3;</code>
   */
  int getSpansCount();
  /**
   * <pre>
   * Span collections included in this segment.
   * </pre>
   *
   * <code>repeated .deeptracing.v1.SpanObject spans = 3;</code>
   */
  java.util.List<? extends org.tracing.network.language.tracing.SpanObjectOrBuilder> 
      getSpansOrBuilderList();
  /**
   * <pre>
   * Span collections included in this segment.
   * </pre>
   *
   * <code>repeated .deeptracing.v1.SpanObject spans = 3;</code>
   */
  org.tracing.network.language.tracing.SpanObjectOrBuilder getSpansOrBuilder(
      int index);

  /**
   * <pre>
   * **Service**. Represents a set/group of workloads which provide the same behaviours for incoming requests.
   *
   * The logic name represents the service. This would show as a separate node in the topology.
   * The metrics analyzed from the spans, would be aggregated for this entity as the service level.
   * </pre>
   *
   * <code>string service = 4;</code>
   * @return The service.
   */
  java.lang.String getService();
  /**
   * <pre>
   * **Service**. Represents a set/group of workloads which provide the same behaviours for incoming requests.
   *
   * The logic name represents the service. This would show as a separate node in the topology.
   * The metrics analyzed from the spans, would be aggregated for this entity as the service level.
   * </pre>
   *
   * <code>string service = 4;</code>
   * @return The bytes for service.
   */
  com.google.protobuf.ByteString
      getServiceBytes();

  /**
   * <pre>
   * **Service Instance**. Each individual workload in the Service group is known as an instance. Like `pods` in Kubernetes, it
   * doesn't need to be a single OS process, however, if you are using instrument agents, an instance is actually a real OS process.
   *
   * The logic name represents the service instance. This would show as a separate node in the instance relationship.
   * The metrics analyzed from the spans, would be aggregated for this entity as the service instance level.
   * </pre>
   *
   * <code>string serviceInstance = 5;</code>
   * @return The serviceInstance.
   */
  java.lang.String getServiceInstance();
  /**
   * <pre>
   * **Service Instance**. Each individual workload in the Service group is known as an instance. Like `pods` in Kubernetes, it
   * doesn't need to be a single OS process, however, if you are using instrument agents, an instance is actually a real OS process.
   *
   * The logic name represents the service instance. This would show as a separate node in the instance relationship.
   * The metrics analyzed from the spans, would be aggregated for this entity as the service instance level.
   * </pre>
   *
   * <code>string serviceInstance = 5;</code>
   * @return The bytes for serviceInstance.
   */
  com.google.protobuf.ByteString
      getServiceInstanceBytes();

  /**
   * <pre>
   * Whether the segment includes all tracked spans.
   * In the production environment tracked, some tasks could include too many spans for one request context, such as a batch update for a cache, or an async job.
   * The agent/SDK could optimize or ignore some tracked spans for better performance.
   * In this case, the value should be flagged as TRUE.
   * </pre>
   *
   * <code>bool isSizeLimited = 6;</code>
   * @return The isSizeLimited.
   */
  boolean getIsSizeLimited();
}
